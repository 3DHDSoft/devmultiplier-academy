{
  "id": "quiz-module-2-lesson-3",
  "lessonId": "lesson-3",
  "moduleId": "module-2",
  "title": "Integration Strategies - Knowledge Check",
  "passingScore": 70,
  "questions": [
    {
      "id": "q1",
      "type": "multiple-choice",
      "question": "Which integration strategies are considered valid approaches between bounded contexts?",
      "options": [
        { "id": "a", "text": "Shared Database and Direct References" },
        { "id": "b", "text": "REST API, gRPC, GraphQL, Domain Events, Message Queues" },
        { "id": "c", "text": "Direct SQL queries across services" },
        { "id": "d", "text": "Copying code between services" }
      ],
      "correctAnswer": "b",
      "explanation": "Valid integration strategies include synchronous approaches (REST API, gRPC, GraphQL) and asynchronous approaches (Domain Events, Message Queues, Kafka). Shared Database and Direct References are anti-patterns."
    },
    {
      "id": "q2",
      "type": "multiple-choice",
      "question": "When is REST API integration best suited?",
      "options": [
        { "id": "a", "text": "When eventual consistency is acceptable" },
        { "id": "b", "text": "For query operations, real-time data needs, and customer-supplier relationships" },
        { "id": "c", "text": "Only for internal services" },
        { "id": "d", "text": "When network latency is not a concern" }
      ],
      "correctAnswer": "b",
      "explanation": "REST API integration is best for query operations, real-time data needs, and customer-supplier relationships where synchronous communication is appropriate."
    },
    {
      "id": "q3",
      "type": "true-false",
      "question": "Shared Database between bounded contexts is an anti-pattern and should be avoided.",
      "correctAnswer": true,
      "explanation": "Shared Database is an anti-pattern because it creates tight coupling between contexts, prevents independent deployment, and violates the principle that each bounded context should own its data."
    },
    {
      "id": "q4",
      "type": "multiple-choice",
      "question": "What is the primary advantage of event-driven integration?",
      "options": [
        { "id": "a", "text": "Simpler to implement than REST" },
        { "id": "b", "text": "Loose coupling and contexts can evolve independently" },
        { "id": "c", "text": "Guaranteed immediate consistency" },
        { "id": "d", "text": "No need for error handling" }
      ],
      "correctAnswer": "b",
      "explanation": "Event-driven integration provides loose coupling, allowing contexts to evolve independently. The publisher doesn't need to know about consumers, and new consumers can be added without changing the publisher."
    },
    {
      "id": "q5",
      "type": "true-false",
      "question": "Domain Events use past-tense naming (like 'OrderPlaced') because they represent things that have already happened.",
      "correctAnswer": true,
      "explanation": "Domain Events are named in past tense (OrderPlaced, PaymentReceived, OrderShipped) because they represent facts about things that have already happened in the domain."
    }
  ]
}
