{
  "id": "quiz-module-4-lesson-4",
  "lessonId": "lesson-4",
  "moduleId": "module-4",
  "title": "Read Models and Projections - Knowledge Check",
  "passingScore": 70,
  "questions": [
    {
      "id": "q1",
      "type": "multiple-choice",
      "question": "What is a read model (projection) in CQRS?",
      "options": [
        { "id": "a", "text": "A normalized database table" },
        { "id": "b", "text": "A denormalized data structure optimized for specific queries" },
        { "id": "c", "text": "The primary source of truth for data" },
        { "id": "d", "text": "A caching layer" }
      ],
      "correctAnswer": "b",
      "explanation": "Read models are denormalized, query-optimized views designed for specific UI needs. They have no business logic, are eventually consistent, and can be rebuilt from events."
    },
    {
      "id": "q2",
      "type": "true-false",
      "question": "Read models should be designed starting from UI requirements, not from the domain model.",
      "correctAnswer": true,
      "explanation": "Read models should match exactly what the UI needs - including pre-formatted values, denormalized relationships, and pre-computed business rules. Design from the wireframe, not from the aggregate."
    },
    {
      "id": "q3",
      "type": "multiple-choice",
      "question": "Why should read models include denormalized data like customer names on orders?",
      "options": [
        { "id": "a", "text": "To save storage space" },
        { "id": "b", "text": "To avoid expensive joins at query time" },
        { "id": "c", "text": "To enforce referential integrity" },
        { "id": "d", "text": "To simplify the write model" }
      ],
      "correctAnswer": "b",
      "explanation": "Denormalizing data (storing customer name directly on the order read model) eliminates the need for expensive joins at query time, making reads faster. Updates to denormalized data are handled by projections."
    },
    {
      "id": "q4",
      "type": "true-false",
      "question": "Read models can be safely deleted and rebuilt from domain events or the write model.",
      "correctAnswer": true,
      "explanation": "Read models are derived data, not the source of truth. They can be completely rebuilt from the event stream or write model. This is useful for schema changes or fixing bugs in projections."
    },
    {
      "id": "q5",
      "type": "multiple-choice",
      "question": "How should cache invalidation be handled for read models?",
      "options": [
        { "id": "a", "text": "Never invalidate - always use stale data" },
        { "id": "b", "text": "Invalidate on relevant domain events" },
        { "id": "c", "text": "Invalidate every minute" },
        { "id": "d", "text": "Disable caching for read models" }
      ],
      "correctAnswer": "b",
      "explanation": "Cache invalidation should be triggered by domain events. When an order is placed or status changes, the projection handler updates the read model AND invalidates the cache for affected data."
    }
  ]
}
