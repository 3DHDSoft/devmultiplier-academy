{
  "id": "quiz-module-3-lesson-4",
  "lessonId": "lesson-4",
  "moduleId": "module-3",
  "title": "Domain Services and Factories - Knowledge Check",
  "passingScore": 70,
  "questions": [
    {
      "id": "q1",
      "type": "multiple-choice",
      "question": "When should you use a domain service instead of putting logic in an entity?",
      "options": [
        { "id": "a", "text": "When you need to improve performance" },
        { "id": "b", "text": "When the operation involves multiple entities or doesn't naturally belong to a single entity" },
        { "id": "c", "text": "When you want to reduce the size of entity classes" },
        { "id": "d", "text": "When you need to access the database" }
      ],
      "correctAnswer": "b",
      "explanation": "Domain services are for operations that don't naturally belong to a single entity, like MoneyTransferService which coordinates between two BankAccount entities, or PricingService that calculates prices based on Product and Customer."
    },
    {
      "id": "q2",
      "type": "true-false",
      "question": "Domain services should be stateless - they should not store instance variables.",
      "correctAnswer": true,
      "explanation": "Domain services must be stateless. They receive all needed data as method parameters and return results. Having state in domain services leads to bugs and makes the services harder to test and reason about."
    },
    {
      "id": "q3",
      "type": "multiple-choice",
      "question": "What is the key difference between a domain service and an application service?",
      "options": [
        { "id": "a", "text": "Domain services are faster" },
        { "id": "b", "text": "Domain services contain business logic; application services orchestrate workflows and coordinate infrastructure" },
        { "id": "c", "text": "Application services are in the domain layer" },
        { "id": "d", "text": "Domain services have database access" }
      ],
      "correctAnswer": "b",
      "explanation": "Domain services contain pure business logic and work only with domain objects. Application services orchestrate use cases, manage transactions, call repositories, and coordinate infrastructure - they are thin and contain no business logic."
    },
    {
      "id": "q4",
      "type": "multiple-choice",
      "question": "What is the purpose of separate 'create' and 'reconstitute' factory methods?",
      "options": [
        { "id": "a", "text": "To improve code readability" },
        { "id": "b", "text": "Create validates and generates IDs for new objects; reconstitute trusts database state and skips validation" },
        { "id": "c", "text": "To support different programming languages" },
        { "id": "d", "text": "To reduce memory usage" }
      ],
      "correctAnswer": "b",
      "explanation": "The create() factory method is for new entities - it validates input, generates IDs, and sets initial state. The reconstitute() method is for loading from database - it trusts the persisted state and skips validation since data was already validated when created."
    },
    {
      "id": "q5",
      "type": "true-false",
      "question": "A factory class is preferred over a factory method when creation requires dependencies or external calls.",
      "correctAnswer": true,
      "explanation": "Simple creation logic can use static factory methods on the entity itself. But when creation requires dependencies (like checking availability or calculating prices), a factory class can be injected with those dependencies."
    }
  ]
}
