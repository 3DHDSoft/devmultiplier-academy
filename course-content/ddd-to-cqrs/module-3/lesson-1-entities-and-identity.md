# Entities and Identity

**Duration:** 18 minutes
**Learning Objectives:**
- Distinguish between entities and value objects
- Understand identity generation strategies
- Implement entity equality and lifecycle management
- Recognize when to use entities in your domain model

---

## Introduction

Entities are one of the fundamental building blocks of DDD. Unlike value objects, entities have a unique identity that persists throughout their lifetime—even as their attributes change. Understanding entities is critical for modeling real-world business concepts correctly.

## What is an Entity?

**Definition:** An object that is defined by its identity rather than its attributes, and has a continuous thread of identity throughout its lifecycle.

### Entity vs Value Object

```typescript
// ❌ Treating everything as entities
class Address {
  constructor(
    public id: string, // Unnecessary ID
    public street: string,
    public city: string,
    public zipCode: string
  ) {}
}

// Two addresses with same values but different IDs are "different"
const addr1 = new Address('uuid-1', '123 Main St', 'Boston', '02101');
const addr2 = new Address('uuid-2', '123 Main St', 'Boston', '02101');
console.log(addr1 === addr2); // false (but they represent the same address!)

// ✅ Entity with identity
class Customer {
  constructor(
    private readonly id: CustomerId, // Identity matters
    private name: string,
    private email: Email
  ) {}

  // Customer remains the same customer even when attributes change
  updateEmail(newEmail: Email): void {
    this.email = newEmail;
    // Still the same customer!
  }
}

// ✅ Value object without identity
class Address {
  constructor(
    public readonly street: string,
    public readonly city: string,
    public readonly zipCode: string
  ) {}

  equals(other: Address): boolean {
    return (
      this.street === other.street &&
      this.city === other.city &&
      this.zipCode === other.zipCode
    );
  }
}
```

### Key Characteristics

1. **Identity:** Has a unique identifier
2. **Mutability:** Can change attributes over time
3. **Lifecycle:** Created, modified, potentially deleted
4. **Equality by ID:** Two entities are equal if they have the same ID

```typescript
class Order {
  private constructor(
    private readonly id: OrderId,
    private customerId: CustomerId,
    private items: OrderItem[],
    private status: OrderStatus,
    private createdAt: Date,
    private updatedAt: Date
  ) {}

  equals(other: Order): boolean {
    // Entities are equal by ID, not by attributes
    return this.id.equals(other.id);
  }

  // Entity can change over time
  addItem(item: OrderItem): void {
    if (this.status !== OrderStatus.Draft) {
      throw new DomainError('Cannot modify submitted orders');
    }
    this.items.push(item);
    this.updatedAt = new Date();
  }

  submit(): void {
    this.ensureHasItems();
    this.status = OrderStatus.Submitted;
    this.updatedAt = new Date();
  }

  // Order's identity never changes
  getId(): OrderId {
    return this.id;
  }
}
```

## Identity Generation Strategies

### 1. UUID/GUID

**Best for:** Distributed systems, client-side generation, immediate identity

```typescript
import { randomUUID } from 'crypto';

class OrderId {
  private constructor(private readonly value: string) {}

  static generate(): OrderId {
    return new OrderId(randomUUID());
  }

  static fromString(value: string): OrderId {
    // Validate UUID format
    if (!/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value)) {
      throw new Error('Invalid UUID format');
    }
    return new OrderId(value);
  }

  equals(other: OrderId): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}

// Usage
const order = Order.create(
  OrderId.generate(), // Generated immediately
  customerId,
  items
);

// Pros:
// ✅ No database round-trip needed
// ✅ Works in distributed systems
// ✅ Can generate on client-side
// ✅ No collision risk

// Cons:
// ❌ Not human-friendly (cc8b8d5c-3f7d-4e1c-9a8f-2d3e4f5a6b7c)
// ❌ Larger than integers (36 chars vs ~10 digits)
// ❌ Poor database index performance if used as clustering key
```

### 2. Database Sequence/Auto-Increment

**Best for:** Single database systems, human-readable IDs

```typescript
class OrderId {
  private constructor(private readonly value: number) {}

  static fromNumber(value: number): OrderId {
    if (value <= 0) {
      throw new Error('Order ID must be positive');
    }
    return new OrderId(value);
  }

  equals(other: OrderId): boolean {
    return this.value === other.value;
  }

  toNumber(): number {
    return this.value;
  }
}

// Must be generated by database
class OrderRepository {
  async save(order: Order): Promise<void> {
    // Database generates ID on insert
    const result = await prisma.orders.create({
      data: {
        customerId: order.getCustomerId().toString(),
        status: order.getStatus(),
        // ... other fields
      },
    });

    // Set ID after database generation
    order.setId(OrderId.fromNumber(result.id));
  }
}

// Pros:
// ✅ Human-friendly (Order #12345)
// ✅ Efficient database indexing
// ✅ Sequential ordering

// Cons:
// ❌ Requires database round-trip
// ❌ Doesn't work in distributed systems
// ❌ Can't generate ID before persistence
// ❌ Reveals business information (total number of orders)
```

### 3. Domain-Specific IDs

**Best for:** Business-meaningful identifiers, external integration

```typescript
class InvoiceNumber {
  private constructor(private readonly value: string) {}

  // Format: INV-2024-001234
  static generate(year: number, sequence: number): InvoiceNumber {
    const paddedSequence = sequence.toString().padStart(6, '0');
    return new InvoiceNumber(`INV-${year}-${paddedSequence}`);
  }

  static fromString(value: string): InvoiceNumber {
    if (!/^INV-\d{4}-\d{6}$/.test(value)) {
      throw new Error('Invalid invoice number format');
    }
    return new InvoiceNumber(value);
  }

  toString(): string {
    return this.value;
  }

  equals(other: InvoiceNumber): boolean {
    return this.value === other.value;
  }
}

class OrderNumber {
  private constructor(private readonly value: string) {}

  // Format: ORD-US-20240113-ABC123
  static generate(country: string, date: Date): OrderNumber {
    const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    return new OrderNumber(`ORD-${country}-${dateStr}-${random}`);
  }

  static fromString(value: string): OrderNumber {
    if (!/^ORD-[A-Z]{2}-\d{8}-[A-Z0-9]{6}$/.test(value)) {
      throw new Error('Invalid order number format');
    }
    return new OrderNumber(value);
  }

  toString(): string {
    return this.value;
  }
}

// Pros:
// ✅ Business-meaningful (year, region, etc. encoded)
// ✅ Human-readable and memorable
// ✅ Useful for customer service
// ✅ Can enforce business rules in format

// Cons:
// ❌ More complex generation logic
// ❌ May need distributed coordination
// ❌ Format changes require migration
```

### 4. Composite Keys

**Best for:** Natural business identifiers, legacy system integration

```typescript
class ReservationId {
  constructor(
    private readonly flightNumber: string,
    private readonly date: Date,
    private readonly seatNumber: string
  ) {}

  equals(other: ReservationId): boolean {
    return (
      this.flightNumber === other.flightNumber &&
      this.date.getTime() === other.date.getTime() &&
      this.seatNumber === other.seatNumber
    );
  }

  toString(): string {
    const dateStr = this.date.toISOString().split('T')[0];
    return `${this.flightNumber}-${dateStr}-${this.seatNumber}`;
  }
}

class FlightReservation {
  constructor(
    private readonly id: ReservationId,
    private passengerName: string,
    private status: ReservationStatus
  ) {}

  getId(): ReservationId {
    return this.id;
  }

  equals(other: FlightReservation): boolean {
    return this.id.equals(other.id);
  }
}

// Pros:
// ✅ Natural key from business domain
// ✅ No artificial ID needed
// ✅ Clear business meaning

// Cons:
// ❌ More complex equality checks
// ❌ Parts of key might change (rare but possible)
// ❌ Larger storage footprint
```

## Entity Equality

```typescript
// ✅ Correct entity equality
class Customer {
  constructor(
    private readonly id: CustomerId,
    private name: string,
    private email: Email
  ) {}

  equals(other: Customer): boolean {
    // Only compare IDs
    return this.id.equals(other.id);
  }

  // TypeScript approach
  [Symbol.for('equals')](other: unknown): boolean {
    return other instanceof Customer && this.equals(other);
  }
}

// Usage
const customer1 = new Customer(
  CustomerId.fromString('123'),
  'John Doe',
  Email.fromString('john@example.com')
);

const customer2 = new Customer(
  CustomerId.fromString('123'),
  'Jane Doe', // Different name
  Email.fromString('jane@example.com') // Different email
);

console.log(customer1.equals(customer2)); // true - same ID
```

### Common Mistakes

```typescript
// ❌ Wrong: Comparing all attributes
class Customer {
  equals(other: Customer): boolean {
    return (
      this.id === other.id &&
      this.name === other.name && // Don't compare attributes!
      this.email === other.email
    );
  }
}

// ❌ Wrong: Using reference equality
const customers = [customer1, customer2];
customers.includes(customer1); // true
customers.includes(customer3); // false even if same ID!

// ✅ Correct: Use custom equality
customers.some(c => c.equals(customer3));
```

## Entity Lifecycle

### Creation

```typescript
class Order {
  // Private constructor enforces factory methods
  private constructor(
    private readonly id: OrderId,
    private readonly customerId: CustomerId,
    private items: OrderItem[],
    private status: OrderStatus,
    private readonly createdAt: Date,
    private updatedAt: Date
  ) {}

  // Factory method for new orders
  static create(customerId: CustomerId, items: OrderItem[]): Order {
    if (items.length === 0) {
      throw new DomainError('Order must have at least one item');
    }

    return new Order(
      OrderId.generate(),
      customerId,
      items,
      OrderStatus.Draft,
      new Date(),
      new Date()
    );
  }

  // Factory method for reconstituting from database
  static reconstitute(
    id: OrderId,
    customerId: CustomerId,
    items: OrderItem[],
    status: OrderStatus,
    createdAt: Date,
    updatedAt: Date
  ): Order {
    // No validation - trust database state
    return new Order(id, customerId, items, status, createdAt, updatedAt);
  }
}
```

### Modification

```typescript
class Order {
  // Entities can be modified through methods
  addItem(item: OrderItem): void {
    this.ensureModifiable();
    this.items.push(item);
    this.updatedAt = new Date();
  }

  removeItem(itemId: string): void {
    this.ensureModifiable();
    this.items = this.items.filter(i => i.id !== itemId);
    this.updatedAt = new Date();
  }

  updateQuantity(itemId: string, quantity: number): void {
    this.ensureModifiable();
    const item = this.findItem(itemId);
    item.updateQuantity(quantity);
    this.updatedAt = new Date();
  }

  private ensureModifiable(): void {
    if (this.status !== OrderStatus.Draft) {
      throw new DomainError('Cannot modify submitted orders');
    }
  }
}
```

### State Transitions

```typescript
enum OrderStatus {
  Draft = 'draft',
  Submitted = 'submitted',
  Paid = 'paid',
  Shipped = 'shipped',
  Delivered = 'delivered',
  Cancelled = 'cancelled',
}

class Order {
  submit(): OrderSubmitted {
    this.ensureStatus(OrderStatus.Draft);
    this.ensureHasItems();

    this.status = OrderStatus.Submitted;
    this.updatedAt = new Date();

    return new OrderSubmitted(this.id, this.customerId, this.items);
  }

  markPaid(payment: Payment): OrderPaid {
    this.ensureStatus(OrderStatus.Submitted);

    this.status = OrderStatus.Paid;
    this.updatedAt = new Date();

    return new OrderPaid(this.id, payment.id);
  }

  ship(trackingNumber: string): OrderShipped {
    this.ensureStatus(OrderStatus.Paid);

    this.status = OrderStatus.Shipped;
    this.updatedAt = new Date();

    return new OrderShipped(this.id, trackingNumber);
  }

  cancel(reason: string): OrderCancelled {
    if (this.status === OrderStatus.Shipped || this.status === OrderStatus.Delivered) {
      throw new DomainError('Cannot cancel shipped or delivered orders');
    }

    this.status = OrderStatus.Cancelled;
    this.updatedAt = new Date();

    return new OrderCancelled(this.id, reason);
  }

  private ensureStatus(expected: OrderStatus): void {
    if (this.status !== expected) {
      throw new DomainError(
        `Expected status ${expected}, but was ${this.status}`
      );
    }
  }
}
```

## When to Use Entities

### Use Entities When:

✅ **Identity matters over attributes**
```typescript
// Customer remains the same even when details change
class Customer {
  updateAddress(newAddress: Address): void {
    this.address = newAddress; // Still the same customer
  }
}
```

✅ **Object has a lifecycle**
```typescript
// Order goes through multiple states
class Order {
  submit() { /* ... */ }
  pay() { /* ... */ }
  ship() { /* ... */ }
}
```

✅ **Object is mutable**
```typescript
// Account balance changes over time
class BankAccount {
  deposit(amount: Money): void {
    this.balance = this.balance.add(amount);
  }
}
```

✅ **Need to track history**
```typescript
class User {
  private loginHistory: LoginEvent[] = [];

  recordLogin(timestamp: Date): void {
    this.loginHistory.push(new LoginEvent(timestamp));
  }
}
```

### Don't Use Entities When:

❌ **Value is defined by attributes**
```typescript
// Address is defined by its attributes, not identity
class Address {
  // This should be a value object, not an entity
  constructor(
    public readonly street: string,
    public readonly city: string
  ) {}
}
```

❌ **Object is immutable**
```typescript
// Money never changes - it's a value object
class Money {
  constructor(
    public readonly amount: number,
    public readonly currency: string
  ) {}

  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.currency);
  }
}
```

❌ **No independent lifecycle**
```typescript
// OrderItem is part of Order's lifecycle
class OrderItem {
  // This should be part of Order aggregate, not a separate entity
}
```

## Real-World Examples

### Example 1: User Entity

```typescript
class UserId {
  private constructor(private readonly value: string) {}

  static generate(): UserId {
    return new UserId(randomUUID());
  }

  static fromString(value: string): UserId {
    return new UserId(value);
  }

  equals(other: UserId): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}

class User {
  private constructor(
    private readonly id: UserId,
    private email: Email,
    private passwordHash: string,
    private profile: UserProfile,
    private status: UserStatus,
    private readonly createdAt: Date,
    private updatedAt: Date,
    private lastLoginAt: Date | null
  ) {}

  static create(email: Email, password: string, profile: UserProfile): User {
    return new User(
      UserId.generate(),
      email,
      hashPassword(password),
      profile,
      UserStatus.Active,
      new Date(),
      new Date(),
      null
    );
  }

  getId(): UserId {
    return this.id;
  }

  updateProfile(newProfile: UserProfile): void {
    this.profile = newProfile;
    this.updatedAt = new Date();
  }

  changePassword(currentPassword: string, newPassword: string): void {
    if (!verifyPassword(currentPassword, this.passwordHash)) {
      throw new DomainError('Current password is incorrect');
    }

    this.passwordHash = hashPassword(newPassword);
    this.updatedAt = new Date();
  }

  recordLogin(): void {
    this.lastLoginAt = new Date();
  }

  suspend(reason: string): UserSuspended {
    if (this.status === UserStatus.Suspended) {
      throw new DomainError('User is already suspended');
    }

    this.status = UserStatus.Suspended;
    this.updatedAt = new Date();

    return new UserSuspended(this.id, reason);
  }

  activate(): void {
    this.status = UserStatus.Active;
    this.updatedAt = new Date();
  }

  equals(other: User): boolean {
    return this.id.equals(other.id);
  }
}
```

### Example 2: Product Entity

```typescript
class ProductId {
  private constructor(private readonly value: string) {}

  static generate(): ProductId {
    return new ProductId(randomUUID());
  }

  static fromString(value: string): ProductId {
    return new ProductId(value);
  }

  toString(): string {
    return this.value;
  }
}

class Product {
  private constructor(
    private readonly id: ProductId,
    private name: string,
    private description: string,
    private price: Money,
    private inventory: number,
    private status: ProductStatus,
    private readonly createdAt: Date,
    private updatedAt: Date
  ) {}

  static create(
    name: string,
    description: string,
    price: Money,
    initialInventory: number
  ): Product {
    if (initialInventory < 0) {
      throw new DomainError('Initial inventory cannot be negative');
    }

    return new Product(
      ProductId.generate(),
      name,
      description,
      price,
      initialInventory,
      ProductStatus.Active,
      new Date(),
      new Date()
    );
  }

  updatePrice(newPrice: Money): ProductPriceChanged {
    const oldPrice = this.price;
    this.price = newPrice;
    this.updatedAt = new Date();

    return new ProductPriceChanged(this.id, oldPrice, newPrice);
  }

  adjustInventory(quantity: number): void {
    const newInventory = this.inventory + quantity;

    if (newInventory < 0) {
      throw new DomainError('Insufficient inventory');
    }

    this.inventory = newInventory;
    this.updatedAt = new Date();
  }

  discontinue(): ProductDiscontinued {
    if (this.status === ProductStatus.Discontinued) {
      throw new DomainError('Product is already discontinued');
    }

    this.status = ProductStatus.Discontinued;
    this.updatedAt = new Date();

    return new ProductDiscontinued(this.id);
  }

  isAvailable(): boolean {
    return this.status === ProductStatus.Active && this.inventory > 0;
  }

  getId(): ProductId {
    return this.id;
  }
}
```

## AI Integration Guidance

### Using AI to Generate Entities

**Good Prompt:**
```
Generate a DDD entity for a BankAccount in a banking system. Include:
- AccountId as a value object using account numbers (format: XXXX-XXXX-XXXX)
- Balance as Money value object
- Account status (Active, Frozen, Closed)
- Methods: deposit, withdraw, freeze, close
- Domain events for all state changes
- Proper validation and invariant protection
- TypeScript with strict types
```

**AI Can Help With:**
- Generating boilerplate (constructors, getters)
- Creating factory methods
- Implementing equality methods
- Generating domain events
- Writing validation logic

**AI Cannot Replace:**
- Domain expert knowledge of business rules
- Understanding of entity lifecycle in your specific context
- Decisions about entity boundaries
- Choosing appropriate identity strategies

### Example AI-Assisted Code Review

```typescript
// AI Prompt: "Review this entity for DDD best practices"

class Account {
  public id: string; // ❌ AI would flag: public mutable ID
  public balance: number; // ❌ AI would flag: primitive obsession

  constructor(id: string, balance: number) {
    this.id = id;
    this.balance = balance;
  }

  // ❌ AI would flag: no validation
  setBalance(amount: number) {
    this.balance = amount;
  }
}

// AI-suggested improvements:
class Account {
  private constructor(
    private readonly id: AccountId, // ✅ Proper identity
    private balance: Money // ✅ Value object
  ) {}

  static create(initialBalance: Money): Account {
    if (initialBalance.isNegative()) {
      throw new DomainError('Initial balance cannot be negative');
    }
    return new Account(AccountId.generate(), initialBalance);
  }

  deposit(amount: Money): AccountDeposited {
    if (amount.isNegativeOrZero()) {
      throw new DomainError('Deposit amount must be positive');
    }
    this.balance = this.balance.add(amount);
    return new AccountDeposited(this.id, amount);
  }
}
```

## Common Pitfalls

### 1. Identity Confusion

```typescript
// ❌ Wrong: Using database ID as business identity
class Order {
  constructor(public databaseId: number) {} // Technical ID
}

// ✅ Correct: Separate business identity
class Order {
  constructor(
    private readonly id: OrderId, // Business identity
    // databaseId handled by repository layer
  ) {}
}
```

### 2. Anemic Entities

```typescript
// ❌ Wrong: Anemic entity with no behavior
class Customer {
  constructor(
    public id: string,
    public name: string,
    public email: string,
    public creditLimit: number
  ) {}
}

class CustomerService {
  canPlaceOrder(customer: Customer, orderTotal: number): boolean {
    return customer.creditLimit >= orderTotal;
  }
}

// ✅ Correct: Rich entity with behavior
class Customer {
  private constructor(
    private readonly id: CustomerId,
    private name: string,
    private email: Email,
    private creditLimit: Money
  ) {}

  canPlaceOrder(orderTotal: Money): boolean {
    return orderTotal.isLessThanOrEqual(this.creditLimit);
  }
}
```

### 3. Over-Exposure

```typescript
// ❌ Wrong: Exposing mutable internals
class Order {
  getItems(): OrderItem[] {
    return this.items; // Returns mutable array!
  }
}

// Caller can modify:
order.getItems().push(new OrderItem(...)); // Bypasses validation

// ✅ Correct: Proper encapsulation
class Order {
  getItems(): readonly OrderItem[] {
    return Object.freeze([...this.items]); // Immutable copy
  }

  addItem(item: OrderItem): void {
    // Controlled modification through methods
    this.ensureCanModify();
    this.items.push(item);
  }
}
```

## Key Takeaways

1. **Entities have identity** - They're defined by their ID, not their attributes
2. **Entities are mutable** - They can change state over time while maintaining identity
3. **Identity strategies vary** - Choose UUID, sequence, or domain-specific based on needs
4. **Equality by ID only** - Don't compare entity attributes for equality
5. **Lifecycle management** - Use factory methods for creation and reconstitution
6. **Encapsulation is critical** - Control how entities are modified
7. **Rich behavior** - Put business logic in entities, not services

## Next Steps

In the next lesson, we'll explore **Value Objects**—the immutable complements to entities that represent descriptive aspects of your domain.

## Hands-On Exercise

**Create an Entity:**

Implement a `Subscription` entity for a SaaS application:

```typescript
// Requirements:
// 1. Identity: SubscriptionId (UUID)
// 2. Attributes:
//    - customerId
//    - planId
//    - status (Trial, Active, Cancelled, Expired)
//    - startDate
//    - expiryDate
// 3. Methods:
//    - create() factory
//    - activate()
//    - cancel()
//    - renew()
//    - isActive()
// 4. Business rules:
//    - Cannot cancel already cancelled subscription
//    - Cannot activate expired subscription
//    - Renewal extends expiry date by plan duration
// 5. Emit domain events for all state changes

// Try implementing it yourself, then check the solution below
```

**Solution:**

```typescript
class SubscriptionId {
  private constructor(private readonly value: string) {}

  static generate(): SubscriptionId {
    return new SubscriptionId(randomUUID());
  }

  static fromString(value: string): SubscriptionId {
    return new SubscriptionId(value);
  }

  equals(other: SubscriptionId): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}

enum SubscriptionStatus {
  Trial = 'trial',
  Active = 'active',
  Cancelled = 'cancelled',
  Expired = 'expired',
}

class Subscription {
  private constructor(
    private readonly id: SubscriptionId,
    private readonly customerId: CustomerId,
    private readonly planId: PlanId,
    private status: SubscriptionStatus,
    private readonly startDate: Date,
    private expiryDate: Date
  ) {}

  static create(
    customerId: CustomerId,
    planId: PlanId,
    trialDays: number
  ): Subscription {
    const startDate = new Date();
    const expiryDate = new Date(startDate);
    expiryDate.setDate(expiryDate.getDate() + trialDays);

    return new Subscription(
      SubscriptionId.generate(),
      customerId,
      planId,
      SubscriptionStatus.Trial,
      startDate,
      expiryDate
    );
  }

  activate(duration: number): SubscriptionActivated {
    if (this.status === SubscriptionStatus.Expired) {
      throw new DomainError('Cannot activate expired subscription');
    }

    this.status = SubscriptionStatus.Active;
    this.expiryDate = new Date();
    this.expiryDate.setDate(this.expiryDate.getDate() + duration);

    return new SubscriptionActivated(this.id, this.expiryDate);
  }

  cancel(): SubscriptionCancelled {
    if (this.status === SubscriptionStatus.Cancelled) {
      throw new DomainError('Subscription is already cancelled');
    }

    this.status = SubscriptionStatus.Cancelled;

    return new SubscriptionCancelled(this.id, new Date());
  }

  renew(duration: number): SubscriptionRenewed {
    if (this.status !== SubscriptionStatus.Active) {
      throw new DomainError('Can only renew active subscriptions');
    }

    const oldExpiry = this.expiryDate;
    this.expiryDate = new Date(this.expiryDate);
    this.expiryDate.setDate(this.expiryDate.getDate() + duration);

    return new SubscriptionRenewed(this.id, oldExpiry, this.expiryDate);
  }

  isActive(): boolean {
    return (
      this.status === SubscriptionStatus.Active &&
      this.expiryDate > new Date()
    );
  }

  getId(): SubscriptionId {
    return this.id;
  }

  equals(other: Subscription): boolean {
    return this.id.equals(other.id);
  }
}
```

---

**Time to complete:** 60 minutes
**Difficulty:** Intermediate

Share your implementation in the course forum!
